# State

Unlike a value, an effect is global: it affects the entire computation.
(Isn't this, in a nutshell, the central fact about effects?
Everything that's tricky about them, if not everything that's
interesting, seems to stem from this.)

This chapter is mostly concerned with one kind of effect: assignment.
"As we have seen, binding is local, but assignment is potentially
global.  It is about the *sharing* of two values between otherwise
unrelated portions of the computation." (p. 103)

Memory will be modeled as a map from a finite set of locations to a
set of *storable values*.  This map is called the *store*.

Whether or not the set of storable values of a language is the same
as its set of expressed values is a design question.  But they are
usually the same set.

A *reference* (NOT a variable reference in the sense of ch. 3!)
represents a location.

Two store-language designs are considered in this chapter: one with
explicit references, and one with implicit.

## 4.2 EXPLICIT-REFS

In this language, references are a new kind of expressed value.

Exp-val = Int + Bool + Proc + Ref(Exp-val)
Den-val = Exp-val

Ref(Exp-val) denotes the set of references to locations containing
expressed values.

The language is PROC extended with the following reference
operations:

* 'newref' allocates a new location and returns a reference to it.

* 'deref' returns the contents of the location that a reference
  represents.

* 'setref' changes the contents of the location represented by
  a reference.

(A 'begin ... end' form analogous to Scheme 'begin' is also added.)

An example:

let x = newref(0)
in letrec even(dummy) =
            if zero?(deref(x))
               then 1
               else begin
                      setref(x, -(deref(x), 1));
                      (odd 888)
                    end
          odd(dummy) =
            if zero?(deref(x))
               then 0
               else begin
                      setref(x, -(deref(x), 1));
                      (even 888)
                    end
in begin setref(x, 13); (odd 888) end

Here, the procedures odd and even communicate through the location
denoted by x, instead of passing values back and forth.

"[C]ommunication through a shared variable can be a kind of
information hiding" (p. 105), since two procedures in a chain can
use the variable rather than the rest of the chain having to pass the
shared data along.

I think the term "hiding" is a little misleading.  The big problem
with mutable variables scoped over many procedures is that they are
*not* hidden from procedures that don't need them.

Since EXPLICIT-REFS allows any expressed value to be stored in a
location, references can themselves be stored:

let x = newref(newref(0));
in begin
     setref(deref(x), 11);
     deref(deref(x));
   end

### 4.2.1 Store-passing

Any expression in this language can have an effect.

In the specification, σ will range over stores.  If σ is a store,
then [l = v]σ is a store "just like σ", except that the location l
is mapped to the value v.

In a *store-passing specification*, the store is passed to the
interpreter as an explicit argument.  The interpreter then returns
a new store.  e.g.

(value-of exp₁ ρ σ₀) = (val₁, σ₁)

So a "pure" operation looks like

(value-of (const-exp n) ρ σ) = (n, σ)

Here, "the store is unchanged" by the evaluation of the constant
expression.

The specification of diff-exps:

               (value-of exp₁ ρ σ₀) = (val₁, σ₁)
               (value-of exp₂ ρ σ₁) = (val₂, σ₂)
--------------------------------------------------------------
(value-of (diff-exp exp₁ exp₂) ρ σ₀) = (⌈⌊val₁⌋ - ⌊val₂⌋⌉, σ₂)

Here, the store is threaded sequentially through the evaluation.
Note that, once the subexpresions have been evaluated, the evaluation
of the diff-exp itself doesn't have any further effects on the store.

if expressions;

               (value-of exp₁ ρ σ₀) = (val₁, σ₁)
--------------------------------------------------------------
  (value-of (if-exp exp₁ exp₂ exp₃ ρ σ₀))
       ⎧ (value-of exp₂ ρ σ₁)    if (expval->bool val₁) = #t
     = ⎨
       ⎩ (value-of exp₃ ρ σ₁)    if (expval->bool val₁) = #f

See Exs. 4.2 through 4.5 for specs. of other familiar forms.

### 4.2.2 Operations on explicit references

Expression ::= newref (Expression)
               [newref-exp (exp1)]

           ::= deref (Expression)
               [deref-exp (exp1)]

           ::= setref (Expression , Expression)
               [setref-exp (exp1 exp2)]

Here are the specs:

    (value-of exp ρ σ₀) = (val, σ₁)       l ∉ dom(σ₁)
-------------------------------------------------------------
 (value-of (newref-exp exp) ρ σ₀) = ((ref-val l), [l=val]σ₁)

The requirement l ∉ dom(σ₁) ensures that the location l is fresh.

         (value-of exp ρ σ₀) = (l, σ₁)
-----------------------------------------------
 (value-of (deref-exp exp) ρ σ₀) = (σ₁(l), σ₁)


             (value-of exp₁ ρ σ₀) = (l, σ₁)
            (value-of exp₂ ρ σ₁) = (val, σ₂)
------------------------------------------------------------
 (value-of (setref-exp exp₁ exp₂) ρ σ₀) = (⌈23⌉, [l=val]σ₂)

The value of a setref expression is completely arbitrary, so here
it's specified to be the numeric value 23.

### 4.2.3 Implementation

The specification of EXPLICIT-REFS doesn't express a crucial fact
that we've assumed about the language: that there is *one* store.
So all of the σs of the above will not, in practice, be different
values, but states of one real location.

The book's model implementation use the Scheme effects to model
effects in EXPLICIT-REFS, and uses a Scheme value to represent the
state of the store.  The store-passing of the specification is
hidden; instead, the store state is represented by a single global
variable.

The store is represented by a list of values; a reference is an
index into this list.  New references are added by appending values.

The store has to be initialized before a program is evaluated.  In
the implementation, this means setting it to the empty list.

See src/explicit-refs-base.scm for the implementation.
