# State

Unlike a value, an effect is global: it affects the entire computation.
(Isn't this, in a nutshell, the central fact about effects?
Everything that's tricky about them, if not everything that's
interesting, seems to stem from this.)

This chapter is mostly concerned with one kind of effect: assignment.
"As we have seen, binding is local, but assignment is potentially
global.  It is about the *sharing* of two values between otherwise
unrelated portions of the computation." (p. 103)

Memory will be modeled as a map from a finite set of locations to a
set of *storable values*.  This map is called the *store*.

Whether or not the set of storable values of a language is the same
as its set of expressed values is a design question.  But they are
usually the same set.

A *reference* (NOT a variable reference in the sense of ch. 3!)
represents a location.

Two store-language designs are considered in this chapter: one with
explicit references, and one with implicit.

## 4.2 EXPLICIT-REFS

In this language, references are a new kind of expressed value.

Exp-val = Int + Bool + Proc + Ref(Exp-val)
Den-val = Exp-val

Ref(Exp-val) denotes the set of references to locations containing
expressed values.

The language is PROC extended with the following reference
operations:

* 'newref' allocates a new location and returns a reference to it.

* 'deref' returns the contents of the location that a reference
  represents.

* 'setref' changes the contents of the location represented by
  a reference.

(A 'begin ... end' form analogous to Scheme 'begin' is also added.)

An example:

let x = newref(0)
in letrec even(dummy) =
            if zero?(deref(x))
               then 1
               else begin
                      setref(x, -(deref(x), 1));
                      (odd 888)
                    end
          odd(dummy) =
            if zero?(deref(x))
               then 0
               else begin
                      setref(x, -(deref(x), 1));
                      (even 888)
                    end
in begin setref(x, 13); (odd 888) end

Here, the procedures odd and even communicate through the location
denoted by x, instead of passing values back and forth.

"[C]ommunication through a shared variable can be a kind of
information hiding" (p. 105), since two procedures in a chain can
use the variable rather than the rest of the chain having to pass the
shared data along.

I think the term "hiding" is a little misleading.  The big problem
with mutable variables scoped over many procedures is that they are
*not* hidden from procedures that don't need them.

Since EXPLICIT-REFS allows any expressed value to be stored in a
location, references can themselves be stored:

let x = newref(newref(0));
in begin
     setref(deref(x), 11);
     deref(deref(x));
   end

### 4.2.1 Store-passing

Any expression in this language can have an effect.

In the specification, σ will range over stores.  If σ is a store,
then [l = v]σ is a store "just like σ", except that the location l
is mapped to the value v.

In a *store-passing specification*, the store is passed to the
interpreter as an explicit argument.  The interpreter then returns
a new store.  e.g.

(value-of exp₁ ρ σ₀) = (val₁, σ₁)

So a "pure" operation looks like

(value-of (const-exp n) ρ σ) = (n, σ)

Here, "the store is unchanged" by the evaluation of the constant
expression.

The specification of diff-exps:

               (value-of exp₁ ρ σ₀) = (val₁, σ₁)
               (value-of exp₂ ρ σ₁) = (val₂, σ₂)
--------------------------------------------------------------
(value-of (diff-exp exp₁ exp₂) ρ σ₀) = (⌈⌊val₁⌋ - ⌊val₂⌋⌉, σ₂)

Here, the store is threaded sequentially through the evaluation.
Note that, once the subexpresions have been evaluated, the evaluation
of the diff-exp itself doesn't have any further effects on the store.

if expressions;

               (value-of exp₁ ρ σ₀) = (val₁, σ₁)
--------------------------------------------------------------
  (value-of (if-exp exp₁ exp₂ exp₃ ρ σ₀))
       ⎧ (value-of exp₂ ρ σ₁)    if (expval->bool val₁) = #t
     = ⎨
       ⎩ (value-of exp₃ ρ σ₁)    if (expval->bool val₁) = #f

See Exs. 4.2 through 4.5 for specs. of other familiar forms.

### 4.2.2 Operations on explicit references

Expression ::= newref (Expression)
               [newref-exp (exp1)]

           ::= deref (Expression)
               [deref-exp (exp1)]

           ::= setref (Expression , Expression)
               [setref-exp (exp1 exp2)]

Here are the specs:

    (value-of exp ρ σ₀) = (val, σ₁)       l ∉ dom(σ₁)
-------------------------------------------------------------
 (value-of (newref-exp exp) ρ σ₀) = ((ref-val l), [l=val]σ₁)

The requirement l ∉ dom(σ₁) ensures that the location l is fresh.

         (value-of exp ρ σ₀) = (l, σ₁)
-----------------------------------------------
 (value-of (deref-exp exp) ρ σ₀) = (σ₁(l), σ₁)


             (value-of exp₁ ρ σ₀) = (l, σ₁)
            (value-of exp₂ ρ σ₁) = (val, σ₂)
------------------------------------------------------------
 (value-of (setref-exp exp₁ exp₂) ρ σ₀) = (⌈23⌉, [l=val]σ₂)

The value of a setref expression is completely arbitrary, so here
it's specified to be the numeric value 23.

### 4.2.3 Implementation

The specification of EXPLICIT-REFS doesn't express a crucial fact
that we've assumed about the language: that there is *one* store.
So all of the σs of the above will not, in practice, be different
values, but states of one real location.

The book's model implementation use the Scheme effects to model
effects in EXPLICIT-REFS, and uses a Scheme value to represent the
state of the store.  The store-passing of the specification is
hidden; instead, the store state is represented by a single global
variable.

The store is represented by a list of values; a reference is an
index into this list.  New references are added by appending values.

The store has to be initialized before a program is evaluated.  In
the implementation, this means setting it to the empty list.

See src/explicit-refs-base.scm for the implementation.

## 4.3 IMPLICIT-REFS

Languages with implicit references do not have references as
expressed values.  Instead, these languages "take common patterns
of allocation, dereferencing, and mutation, and package them up
as part of the language."

Here, every variable denotes a reference, and every denoted value
is a reference to a location containing an expressed value:

Exp-val = Int + Bool + Proc
Den-val = Ref(Exp-val)

To evaluate a variable expression in this language, two lookups are
required: first, in an environment, to find the reference, and
second, in the store, to find the contents of the location denoted
by that reference.

Location contents are changed by the 'set' form:

Expression ::= set Identifier = Expression
               [assign-exp (var exp1)]

This language, like Scheme, has mutable variables.  Since references
aren't expressed values, chains of references ("pointers to pointers")
are impossible in this language.

### 4.3.1 Specification

The two-step dereference-then-lookup semantics for var-exps:

(value-of (var-exp var) ρ σ) = (σ(ρ(var)), σ)

Assignment:

                 (value-of exp₁ ρ σ₀) = (val₁, σ₁)
-------------------------------------------------------------------
 (value-of (assign-exp var exp₁) ρ σ₀) = (⌈27⌉, [ρ(var) = val₁]σ₁)

Application:

(apply-procedure (procedure var body ρ) val σ) =
  (value-of body [var = l]ρ [l = val]σ)

Here, l is a location not in the domain of σ.  As in Scheme, the body
is evaluated in an environment in which var is bound to a fresh
location containing val.

See ex_4-14.txt for the let specification.

### 4.3.2 IMPLICIT-REFS implementation

The main question with the implementation is when new references
are created.  This occurs in exactly four places: in environment
initialization, lets, letrecs, and procedure calls.

IMPLICIT-REFS also uses multi-binding letrec from Ex. 3.32, for
whatever reason.

See src/implcit-refs.scm for (the adapted version of) the book's
implementation.

## Explicit vs. implicit

It's worth noting some of the strengths and weaknesses of the two
approaches to references.  EXPLICIT-REFS gives you some control over
mutation, since assignment can *only* happen through reference values;
it's a type error to try to "mutate a variable".  This isolates the
feature, and may make programs easier to understand.  (It's similar to
modern imperative languages that provide mutable and immutable variables.)

On the other hand, IMPLICIT-REFS makes things *much* simpler by dispensing
with reference values, which makes confusing (if powerful) techniques
like reference chaining impossible.  Still, in this language every
variable is mutable.
