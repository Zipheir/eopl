# Chapter 3: Expressions

Binding and scope of variables, illustrated through a number of
little languages with environments.

In each case, this means writing an interpreter, or possibly a
compiler and interpreter (for the target language).

Regardless, a *front end* will be used to translate a program
into a value (an “abstract syntax tree”) behaving as an internal
representation.

This involves scanning and parsing.  An alternative when working
in Lisp is to write a language in S-expression form and just use
‘read’ to do all of that.

## 3.2 LET: A simple language

The grammar for LET (figure 3.2):

Program ::= Expression
            [a-program (exp1)]

Expression ::= Number
               [const-exp (num)]

           ::= - (Expression , Expression)
               [diff-exp (exp1 exp2)]

           ::= zero? Expression
               [zero?-exp (exp1)]

           ::= if Expression then Expression else Expression
               [if-exp (exp1 exp2 exp3)]

           ::= Identifier
               [var-exp (var)]

           ::= let Identifier = Expression in Expression
               [let-exp (var exp1 body)]

### 3.2.2

Each language manipulates at least two sets of values: expressed
values and denoted values.  Here, the former are “the possible
values of expressions”, and the latter are “the values bound to
variables”. (p. 61)

This is interesting, although the use of the term “denoted” seems a
bit confusing.  Clearly there are languages in which “locations in
a store” are denoted values, and even possibly expressed values (as
in C).

In LET and other languages of this chapter, the two sets of values
are the same:

Exp-Val = Int + Bool
Den-Val = Int + Bool

These are types with the obvious constructors, num-val and bool-val,
and extractors, expval->num and expval->bool (undefined when given
the wrong disjunct).

### 3.2.2 Environments

Once again, environments are functions from a finite set of names
to Den-Val, the set of denoted values.  The following language
is used for talking about environments:

• ρ ranges over environments.

• [] denotes the empty environment.

• [var = val]ρ denotes (extend-env var val ρ).

• [var₁ = val₁, var₂ = val₂]ρ ≡ [var₁ = val₁]([var₂ = val₂]ρ), etc.

• [var₁ = val₁, var₂ = val₂, …] denotes the environment in which
  var₁ is bound to val₁, and so on.

### 3.2.4 Specifying the behavior of expressions

The core procedure for making sense of the LET language is the
observer value-of : Exp × Env → Exp-Val, which is, of course,
the interpreter.

The (incomplete) specification of value-of (p. 62):

> (value-of (const-exp n) ρ) = (num-val n)
>
> (value-of (var-exp var) ρ) = (apply-env ρ var)
>
> (value-of (diff-exp exp₁ exp₂) ρ) =
>   (num-val (- (expval->num (value-of exp₁ ρ))
>               (expval->num (value-of exp₂ ρ))))

Note that, to evaluate a diff-exp, the operands are evaluated,
the numeric values extracted and subtracted, then the difference
is expressed as a num-val (i.e. “brought back into” the Exp-Val
type).

Shorthands:

⌈n⌉   ≡ (num-val n)
⌊val⌋ ≡ (expval->num val)

(And similarly for bool-val and expval->bool.)  In addition,
«exp» denotes the tree-type internal representation for exp.
The the above spec. for value-of can be rewritten more concisely:

(value-of «n» ρ) = ⌈n⌉

(value-of «var» ρ) = (apply-env ρ var)

(value-of «-(exp₁, exp₂)») =
  ⌈(- ⌊(value-of «exp₁» ρ)⌋ ⌊(value-of «exp₂» ρ)⌋)⌉


In the LET language, a program is an expression, so finding the
value of a program is just a matter of evaluating it in some
initial environment.

### 3.2.6 Specifying conditionals

This section adds the interface for booleans in LET.

Equationally (which is more concise than the inference rule
versio), the specifications are:

;; zero?-exp
(value-of (zero?-exp exp₁) ρ) =
  (if (zero? ⌊(value-of exp₁ ρ)⌋)
      ⌈#t⌉
      ⌈#f⌉)

;; if-exp
(value-of (if-exp exp₁ exp₂ exp₃) ρ) =
  (if (expval->bool (value-of exp₁ ρ))
      (value-of exp₂ ρ)
      (value-of exp₃ ρ))

### 3.2.7 Specifying let

Now the interesting part.  An example of the let syntax:

let x = 5 in -(x, 3)

Lets can be nested, and bindings can be shadowed:

let z = 5
in let x = 3
   in let y = -(x, 1)
      in let x = 4
         in -(z, -(x, y))  % here x = 4

The equational specification:

(value-of (let-exp var exp₁ body) ρ)
  = (value-of body [var = (value-of exp₁ ρ)]ρ)

## 3.3 PROC: A language with procedures

In PROC, procedures are expressed and denoted values:

Exp-val = Int + Bool + Proc
Den-val = Int + Bool + Proc

Syntax for creating and applying procedures:

Expression ::= proc (Identifier) Expression
               [proc-exp (var body)]
           ::= (Expression Expression)
               [call-exp (rator rand)]

What information must the Proc type include?  This is a language
with lexical scope, so constructing a procedure means saving its
environment.  The spec. for a proc expression:

(value-of (proc-exp var body) ρ) = (proc-val (procedure var body ρ))

proc-val will be the constructor for expressed procedure values.

Partial semantics for procedure calls:

(value-of (call-exp rator rand) ρ) =
  (let ((proc (expval->proc (value-of rator ρ)))
        (arg (value-of rand ρ)))
    (apply-procedure proc arg))

Applying a procedure must evaluate the procedure body in an
extended environment, in which the formal parameter is bound to
the argument of the call.  All other names in the procedure body
must have the same bindings that they did at the time when the
procedure was created.  This is expressed by the condition:

(apply-procedure (procedure var body ρ) val)
  = (value-of body [var=val]ρ)

(Based on the example calculation on p. 77, it seems that PROC
extends LET, i.e. the semantics for most things are the same as
in that language.)

### 3.3.2 Representation

The first approach in this section “proceduralizes
procedures” (see §2.2.3).  This is very straightforward:
procedures in PROC are represented by Scheme procedures.
Here’s the ‘procedure’ constructor; everything else is obvious
from it:

;; procedure : Var × Exp × Env → Proc
(define (procedure var body env)
  (lambda (val)
    (value-of body (extend-env var val env))))

A more explicit representation using a new type:

(define-datatype proc proc?
  (procedure
    (var identifier?)
    (body expression?)
    (saved-env environment?)))

;; apply-procedure : Proc × Exp-val → Exp-val
(define (apply-procedure proc1 val)
  (cases proc proc1
    (procedure (var body saved-env)
      (value-of body (extend-env var val saved-env)))))

This kind of structure would traditionally be called a *closure*.
[Not my favorite terminology.]

## 3.4 LETREC

This language allows recursive definitions, e.g.

letrec double(x) = if zero?(x)
                      then 0
                      else -((double -(x, 1)), -2)
in (double 6)

Note that the syntax of the letrec form is specialized to
allow only unary procedure bindings.  The syntax:

Expression ::=  letrec Identifier (Identifier) =
                  Expression in Expression
                [letrec-exp (p-name b-var p-body letrec-body)]

The specification of letrec's desired behavior:

(value-of (letrec-exp proc-name bound-var proc-body letrec-body) ρ)
  = (value-of letrec-body
              (extend-env-rec proc-name bound-var proc-body ρ))

This of course just kicks the can to extend-env-rec.  Instead of
specifying this directly, the environment it produces is described
through apply-env.  If

ρ₁ := (extend-env-rec proc-name bound-var proc-body ρ),

then

(apply-env ρ₁ proc-name) =
  (proc-val (procedure bound-var proc-body ρ₁))

and, for var ≠ proc-name,

(apply-env ρ₁ var) = (apply-env ρ var)

In other words, the environment ρ₁ returned by
(extend-env-rec proc-name … ρ) binds proc-name to a procedure value
whose saved environment is itself ρ₁.  (This is the magic part.)
Otherwise, it contains the same bindings as ρ.

A new type of environments is defined (p. 86):

(define-datatype environment environment?
  (empty-env)
  (extend-env
    (var identifier?)
    (val expval?)
    (env environment?))
  (extend-env-rec
    (p-name identifier?)
    (b-var identifier?)
    (body expression?)
    (env environment?)))

(define (apply-env env search-var)
  (cases environment env
    (empty-env ()
      (report-no-binding-found search-var))
    (extend-env (saved-var saved-val saved-env)
      (if (eqv? saved-var search-var)
          saved-val
          (apply-env saved-env search-var)))
    (extend-env-rec (p-name b-var p-body saved-env)
      (if (eqv? search-var p-name)
          (proc-val (procedure b-var p-body env))
          (apply-env saved-env search-var)))))

This is really clever.  By constructing the procedure value "on
demand", this implementation avoids the circularity of reference
that seemed to be inherent in the spec. of extend-env-rec.  (And
there's no "lets-and-sets!" hack, either.)
