# Chapter 6

This chapter works toward a process for transforming programs
into CPS.  This will mainly use a procedural representation for
continuations.  Here's the CPS version of a factorial program:

(define (fact n)
  (fact/k n (end-cont)))

(define (fact/k n cont)
  (if (zero? n)
      (apply-cont 1)
      (fact/k (- n 1) (fact-cont n cont))))

The continuations:

(define (end-cont)
  (lambda (val)
    val))

(define (fact-cont n cont)
  (lambda (val)
    (apply-cont cont (* n val))))

Here, apply-cont is just application, so it can be elided.
This, along with inlining the definitions, gives a compact
version:

(define (fact n)
  (fact/k n (lambda (v) v)))

(define (fact/k n cont)
  (if (zero? n)
      (cont 1)
      (fact/k (- n 1)
              (lambda (val)
                (cont (* n val))))))

A similar transformation on a Fibonacci function:

(define (fib n)
  (if (< n 2)
      1
      (+ (fib (- n 1))
         (fib (- n 2)))))

CPSed, with everything inlined:

(define (fib n)
  (fib/k n (lambda (v) v)))

(define (fib/k n cont)
  (if (< n 2)
      (cont 1)
      (fib/k (- n 1)
             (lambda (val1)
               (fib/k (- n 2)
                      (lambda (val2)
                        (cont (+ val1 val2))))))))

Note how inlining does reduce the complexity of the continuations,
since nested scope means some things don't have to be passed as
arguments.

An interesting observation on the fact/k program is that each
continuation just multiplies the value passed to it, i.e. they're
all of the form (lambda (val) (* k val)).  So they can be represented
by just the number k:

(define (end-cont) 1)

(define (fact-cont n k) (* n k))

(define (apply-cont cont val) (* cont val))

Inlined, we have something very similar to fact-iter:

(define (fact n)
  (fact/k n 1))

(define (fact/k n k)
  (if (zero? n)
      k
      (fact/k (- n 1) (* n k))))

There's an interesting observation here: An accumulator is an
optimized representation of a continuation!

## 6.2 Tail form

The input language for the CPS translation will be LETREC with
multi-argument procedures and letrec bindings.  This language
will be called CPS-IN, and expressions in it will be called
*input expressions* for clarity.

The first step is to find a subset of CPS-IN expressions which
don't accumulate control context.  (i.e. "tail position" has to
be defined for the language.)

An expression is in *tail form* if every procedure call, and
every expression containing a procedure call, is in tail position.
(They give the example of (if (zero? x) (f y) (g z)), which makes
no sense--obviously (zero? x) is not in tail position.  Otherwise,
this seems clear.)

Figuring out what tail positions are requires knowing the
meaning of the language.  Here are the tail positions (marked
with T, non-tail positions are marked O for "operand") for the
language CPS-IN:

zero?(O)
-(O, O)
if O then T else T
let Var = O in T
letrec {Var (Var *) = T}* in T
proc (Var *) T
(O O ... O)

In each case, the value of a tail-position subexpression
could become the value of the entire expression.  Subexpressions
in operand position are the ones that extend the control context,
while the ones in tail position are evaluated in the original
continuation.  From this, the CPS-OUT target language can be
defined.

This language has two nonterminals, Simple-exp and Tf-exp.
The expressions in Simple-exp are free of procedure calls, and
those in Tf-exp are guaranteed to be in tail form.

Here's the grammar (p. 208):

Program ::= Tf-exp
            [a-program (exp1)]

Simple-exp ::= Number
               [const-exp (num)]

           ::= Identifier
	       [var-exp (var)]

           ::= -(Simple-exp, Simple-exp)
	       [cps-diff-exp (simple1 simple2)]

           ::= zero?(Simple-exp)
	       [cps-zero?-exp (simple1)]

           ::= proc ({Identifier}*) Tf-exp
	       [cps-proc-exp (vars body)]

Tf-exp ::= Simple-exp
           [simple-exp->exp (simple1)]

       ::= let Identifier = Simple-exp in Tf-exp
           [cps-let-exp (var simple1 body)]

       ::= letrec {Identifier ({Identifier}*) = Tf-exp}* in Tf-exp
           [cps-letrec-exp (p-names b-varss p-bodies body)]

       ::= if Simple-exp then Tf-exp else Tf-exp
           [cps-if-exp (simple1 body1 body2)]

       ::= (Simple-exp {Simple-exp}*)
           [cps-call-exp (rator rands)]
